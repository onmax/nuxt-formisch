---
icon: ph:shield-check-duotone
---

# Server Validation

nuxt-formisch provides `useFormValidation` for validating request bodies against schemas in server routes. Uses the [Standard Schema](https://github.com/standard-schema/standard-schema) specification, supporting Valibot, Zod, and ArkType.

## useFormValidation

Validates the request body against a schema using h3's `readValidatedBody`. Returns the validated data or throws a 400 error with validation details.

```ts [server/api/login.post.ts]
import { loginSchema } from '#shared/utils/schemas'

export default defineEventHandler(async (event) => {
  const data = await useFormValidation(event, loginSchema)

  // data is fully typed as v.InferOutput<typeof loginSchema>
  return { success: true, user: data.email }
})
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `event` | `H3Event` | The h3 event from the handler |
| `schema` | `StandardSchemaV1` | Any Standard Schema-compatible schema (Valibot, Zod, ArkType) |

## Return Value

Returns `Promise<v.InferOutput<TSchema>>` with the validated and transformed data.

## Error Handling

When validation fails, `useFormValidation` throws an error that results in a 400 response with validation details.

```json
{
  "statusCode": 400,
  "message": "Validation failed",
  "data": {
    "issues": [
      {
        "path": ["email"],
        "message": "Invalid email"
      }
    ]
  }
}
```

## Standard Schema Support

`useFormValidation` accepts any schema implementing the Standard Schema specification:

::code-group
```ts [Valibot]
import * as v from 'valibot'

const schema = v.object({
  email: v.pipe(v.string(), v.email()),
  password: v.pipe(v.string(), v.minLength(8))
})
```

```ts [Zod]
import { z } from 'zod'

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
})
```

```ts [ArkType]
import { type } from 'arktype'

const schema = type({
  email: 'string.email',
  password: 'string >= 8'
})
```
::

## Shared Schemas

Place schemas in `shared/utils/` to use them in both client and server code. Nuxt auto-imports from this directory.

::code-group
```ts [shared/utils/schemas.ts]
import * as v from 'valibot'

export const loginSchema = v.object({
  email: v.pipe(v.string(), v.email('Invalid email')),
  password: v.pipe(v.string(), v.minLength(8, 'Password must be 8+ chars'))
})

export type LoginInput = v.InferInput<typeof loginSchema>
export type LoginOutput = v.InferOutput<typeof loginSchema>
```

```ts [server/api/login.post.ts]
import { loginSchema } from '#shared/utils/schemas'

export default defineEventHandler(async (event) => {
  const data = await useFormValidation(event, loginSchema)

  // Authenticate user...
  return { token: 'jwt...' }
})
```

```vue [pages/login.vue]
<template>
  <FForm :of="form" :on-submit="onSubmit">
    <input v-model="emailField.input" type="email" />
    <input v-model="passwordField.input" type="password" />
    <button type="submit">Login</button>
  </FForm>
</template>

<script setup lang="ts">
import type { LoginOutput } from '#shared/utils/schemas'

// loginSchema is auto-imported
const form = useForm({ schema: loginSchema })
const emailField = useField(() => form, () => ({ path: ['email'] as const }))
const passwordField = useField(() => form, () => ({ path: ['password'] as const }))

async function onSubmit(values: LoginOutput) {
  const { token } = await $fetch('/api/login', {
    method: 'POST',
    body: values
  })
}
</script>
```
::

## Implementation

Under the hood, `useFormValidation` uses h3's `readValidatedBody` with the Standard Schema `~standard` property.

```ts
import { readValidatedBody } from 'h3'
import type { StandardSchemaV1 } from '@standard-schema/spec'

export async function useFormValidation<T>(event: H3Event, schema: StandardSchemaV1<unknown, T>): Promise<T> {
  return await readValidatedBody(event, data => schema['~standard'].validate(data))
}
```
