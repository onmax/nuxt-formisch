---
icon: ph:magic-wand-duotone
---

# AutoForm

AutoForm generates forms from Valibot schemas with Nuxt UI components. Define your schema once and get a working form with validation, proper input types, and styling.

## Basic Usage

Pass a Valibot object schema to `AutoForm`. The component introspects the schema and renders appropriate Nuxt UI inputs for each field.

```vue [app.vue]
<template>
  <AutoForm :schema="schema" @submit="onSubmit">
    <template #actions="{ isDirty, isSubmitting }">
      <UButton type="submit" :loading="isSubmitting" :disabled="!isDirty">
        Save
      </UButton>
    </template>
  </AutoForm>
</template>

<script setup lang="ts">
import * as v from 'valibot'

const schema = v.object({
  name: v.pipe(v.string(), v.minLength(2)),
  email: v.pipe(v.string(), v.email()),
  age: v.pipe(v.number(), v.minValue(18)),
  active: v.boolean()
})

function onSubmit(data: v.InferOutput<typeof schema>) {
  console.log(data)
}
</script>
```

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `schema` | `Schema` | required | Valibot object schema |
| `initialValues` | `Record<string, unknown>` | `undefined` | Pre-fill form values |
| `fieldConfig` | `Record<string, FieldConfig>` | `undefined` | Override field behavior |
| `columns` | `1 \| 2 \| 3 \| 4` | `1` | Grid columns |
| `validateOn` | `'blur' \| 'input' \| 'change'` | `'blur'` | When to validate |
| `disabled` | `boolean` | `false` | Disable all fields |
| `ui` | `Partial<Record<SlotKeys, string>>` | `undefined` | Override slot classes |

## Events

| Event | Payload | Description |
|-------|---------|-------------|
| `@submit` | `Record<string, unknown>` | Emits validated data on successful submission |
| `@error` | `Record<string, string>` | Emits validation errors on failure |

## Field Types

AutoForm maps Valibot schema types to Nuxt UI components:

| Schema Type | Component | Notes |
|-------------|-----------|-------|
| `v.string()` | `UInput` | Text input |
| `v.number()` | `UInput type="number"` | Number input |
| `v.boolean()` | `UCheckbox` | Checkbox |
| `v.picklist([...])` | `USelect` | Select with options |
| `v.object({...})` | Nested fieldset | Recursive rendering |
| `v.array(v.object({...}))` | Repeatable group | Add/remove items |

### Email Detection

Fields with `v.email()` validation render as `type="email"` inputs.

```ts [schema.ts]
const schema = v.object({
  contact: v.pipe(v.string(), v.email()) // Renders as email input
})
```

## Schema Metadata

Enhance fields with Valibot's built-in metadata functions. AutoForm extracts and applies this information automatically.

```ts [schema.ts]
import * as v from 'valibot'

const schema = v.object({
  price: v.pipe(
    v.number(),
    v.minValue(0),
    v.title('Product Price'),
    v.description('Enter the price in USD'),
    v.metadata({ unit: '$', placeholder: '0.00', section: 'Pricing' })
  ),
  category: v.pipe(
    v.picklist(['electronics', 'clothing', 'food']),
    v.title('Category'),
    v.metadata({ section: 'Details' })
  )
})
```

### Available Metadata

| Function | Effect |
|----------|--------|
| `v.title('Label')` | Sets field label |
| `v.description('Help text')` | Sets help/description text |
| `v.metadata({ unit })` | Shows unit suffix (e.g., "$", "kg") |
| `v.metadata({ placeholder })` | Sets input placeholder |
| `v.metadata({ section })` | Groups field under section heading |

## Slots

AutoForm exposes slots for customizing specific fields, sections, or the submit area.

### Field Slots

Override individual field rendering with `field:{name}` slots:

```vue [app.vue]
<template>
  <AutoForm :schema="schema" @submit="onSubmit">
    <template #field:avatar="{ field, store }">
      <UFormField :label="field.ui.label" :error="store.errors?.[0]">
        <ImageUploader v-model="store.input" />
      </UFormField>
    </template>

    <template #actions>
      <UButton type="submit">Save</UButton>
    </template>
  </AutoForm>
</template>
```

### Section Slots

Override entire sections with `section:{name}` slots:

```vue [app.vue]
<template>
  <AutoForm :schema="schema" @submit="onSubmit">
    <template #section:billing="{ fields }">
      <UCard>
        <h3>Billing Information</h3>
        <AutoFormField
          v-for="field in fields"
          :key="field.name"
          :field="field"
        />
      </UCard>
    </template>
  </AutoForm>
</template>
```

### Actions Slot

The `actions` slot receives form state for conditional UI:

```vue [app.vue]
<template>
  <AutoForm :schema="schema" @submit="onSubmit">
    <template #actions="{ isDirty, isSubmitting, reset }">
      <div class="flex gap-2">
        <UButton variant="ghost" @click="reset" :disabled="!isDirty">
          Reset
        </UButton>
        <UButton type="submit" :loading="isSubmitting" :disabled="!isDirty">
          Submit
        </UButton>
      </div>
    </template>
  </AutoForm>
</template>
```

## Nested Objects

AutoForm recursively renders nested object schemas:

```ts [schema.ts]
const schema = v.object({
  user: v.object({
    name: v.string(),
    email: v.pipe(v.string(), v.email())
  }),
  address: v.object({
    street: v.string(),
    city: v.string(),
    zip: v.string()
  })
})
```

## Arrays

Array fields with object items render as repeatable groups with add/remove controls:

```ts [schema.ts]
const schema = v.object({
  contacts: v.array(v.object({
    name: v.string(),
    phone: v.string()
  }))
})
```

## Grid Layout

Use `columns` and `colSpan` for responsive layouts:

```vue [app.vue]
<template>
  <AutoForm
    :schema="schema"
    :columns="2"
    :field-config="{
      description: { colSpan: 2 }
    }"
    @submit="onSubmit"
  >
    <template #actions>
      <UButton type="submit">Save</UButton>
    </template>
  </AutoForm>
</template>

<script setup lang="ts">
import * as v from 'valibot'

const schema = v.object({
  firstName: v.string(),
  lastName: v.string(),
  description: v.string() // Spans full width
})

function onSubmit(data: v.InferOutput<typeof schema>) {
  console.log(data)
}
</script>
```
