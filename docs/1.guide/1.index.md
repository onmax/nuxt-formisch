---
icon: ph:rocket-duotone
---

# Getting Started

nuxt-formisch provides schema-based, headless form handling for Nuxt applications. It wraps `@formisch/vue` with auto-imports for composables, components, and server-side validation.

## Features

- Auto-imports `useForm`, `useField`, `useFieldArray` composables
- Auto-imports `FForm`, `FField`, `FFieldArray` components
- Auto-imports all form methods (`focus`, `reset`, `validate`, etc.)
- Server-side validation with `useFormValidation`
- Full TypeScript support with schema inference

## Installation

::steps

### Install the package

```bash [Terminal]
pnpm add nuxt-formisch @formisch/vue valibot
```

### Add the module

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['nuxt-formisch']
})
```

::

## Basic Usage

Create a form with client-side validation using Valibot schemas.

```vue [app.vue]
<template>
  <FForm :of="form" :on-submit="onSubmit">
    <input v-model="emailField.input" type="email" />
    <p v-if="emailField.errors">{{ emailField.errors[0] }}</p>
    <button type="submit">Submit</button>
  </FForm>
</template>

<script setup lang="ts">
import * as v from 'valibot'

const schema = v.object({
  email: v.pipe(v.string(), v.email('Invalid email'))
})

const form = useForm({ schema })
const emailField = useField(() => form, () => ({ path: ['email'] as const }))

function onSubmit(values: v.InferOutput<typeof schema>) {
  console.log(values)
}
</script>
```

## Full-Stack Validation

Share schemas between client and server using Nuxt's `shared/` directory for type-safe validation on both ends.

::steps

### Create shared schemas

Place schemas in `shared/utils/` for auto-import in both client and server code.

```ts [shared/utils/schemas.ts]
import * as v from 'valibot'

export const loginSchema = v.object({
  email: v.pipe(v.string(), v.email('Invalid email')),
  password: v.pipe(v.string(), v.minLength(8, 'Password must be 8+ chars'))
})

export type LoginInput = v.InferInput<typeof loginSchema>
export type LoginOutput = v.InferOutput<typeof loginSchema>
```

### Use in API routes

The `useFormValidation` composable validates request bodies against your schema.

```ts [server/api/login.post.ts]
import { loginSchema } from '#shared/utils/schemas'

export default defineEventHandler(async (event) => {
  const data = await useFormValidation(event, loginSchema)
  return { success: true, user: data.email }
})
```

### Use the same schema in the frontend

```vue [pages/login.vue]
<template>
  <FForm :of="form" :on-submit="onSubmit">
    <input v-model="emailField.input" type="email" />
    <p v-if="emailField.errors">{{ emailField.errors[0] }}</p>

    <input v-model="passwordField.input" type="password" />
    <p v-if="passwordField.errors">{{ passwordField.errors[0] }}</p>

    <button type="submit">Login</button>
  </FForm>
</template>

<script setup lang="ts">
import type { LoginOutput } from '#shared/utils/schemas'

const form = useForm({ schema: loginSchema })
const emailField = useField(() => form, () => ({ path: ['email'] as const }))
const passwordField = useField(() => form, () => ({ path: ['password'] as const }))

async function onSubmit(values: LoginOutput) {
  await $fetch('/api/login', { method: 'POST', body: values })
}
</script>
```

::

## Auto-Imports

The module automatically imports the following from `@formisch/vue`:

### Composables

`useForm`, `useField`, `useFieldArray`

### Components

`FForm`, `FField`, `FFieldArray`

### Methods

`focus`, `getAllErrors`, `getErrors`, `getInput`, `handleSubmit`, `insert`, `move`, `remove`, `replace`, `reset`, `setErrors`, `setInput`, `submit`, `swap`, `validate`

### Types

`SubmitHandler`, `FormConfig`, `Schema`, `FieldElement`, `DeepPartial`, `PartialValues`, `PathValue`, `RequiredPath`, `ValidArrayPath`, `ValidationMode`, `ValidPath`

### Server Composables

`useFormValidation`
